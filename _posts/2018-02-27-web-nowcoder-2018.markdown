---
layout:     post
title:      "Topics of FE "
subtitle:   "collected from nowcoder"
date:       2018-03-01 19:55:00
author:     "Chaoran"
header-img: "img/post-bg-fe-topics.jpeg"
noToc:      true
tags:
    - 前端开发
---

> “To be is to be perceived. ”

* 目录
{:toc #toc}

## 1. HTML
#### 1.1. html5
> HTML5指的是包括 HTML 、 CSS 和 JavaScript 在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（ Plug-in-Based Rich Internet Application ， RIA ），例如： AdobeFlash 、 Microsoft Silverlight 与 Oracle JavaFX 的需求，并且提供更多能有效加强网络应用的标准集。

**对WEB标准以及W3C的理解与认识**
标签闭合、标签小写、不乱嵌套、提高搜索机器人搜索几率、使用外 链css和 js 脚本、结构行为表现的分离、文件下载与页面速度更快、内容能被更多的用户所访问、内容能被更广泛的设备所访问、更少的代码和组件，容易维 护、改版方便，不需要变动页面内容、提供打印版本而不需要复制内容、提高网站易用性


HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。
1. 拖拽释放(Drag and drop) API 
2. 语义化更好的内容标签（header,nav,footer,aside,article,section）
3. 音频、视频API(audio,video)
4. 画布(Canvas) API
5. 地理(Geolocation) API
6. 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失；
7. sessionStorage 的数据在浏览器关闭后自动删除
8. 表单控件，calendar、date、time、email、url、search  
9. 新的技术webworker, websocket, Geolocation

**移除的元素：**
1. 纯表现的元素：basefont，big，center，font, s，strike，tt，u；
2. 对可用性产生负面影响的元素：frame，frameset，noframes；

#### 1.2. 语义化
1. 去掉或者丢失样式的时候能够让页面呈现出清晰的结构
2. 有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；
3. 方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；
4. 便于团队开发和维护，语义化使得网页更具可读性，是进一步开发网页的必要步骤，遵循W3C标准的团队都遵循这个标准，可以减少差异化。

#### 1.3. Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?
1. <!DOCTYPE> 声明位于文档中的最前面，处于 html 标签之前。告知浏览器以何种模式来渲染文档 
    * 声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。
2. 严格模式的排版和 JS 运作模式是  以该浏览器支持的最高标准运行。
3. 在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。
4. DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。

#### viewport
```html
<meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no" />
<!--
    // width    设置viewport宽度，为一个正整数，或字符串‘device-width’
    // device-width  设备宽度
    // height   设置viewport高度，一般设置了宽度，会自动解析出高度，可以不用设置
    // initial-scale    默认缩放比例（初始缩放比例），为一个数字，可以带小数
    // minimum-scale    允许用户最小缩放比例，为一个数字，可以带小数
    // maximum-scale    允许用户最大缩放比例，为一个数字，可以带小数
    // user-scalable    是否允许手动缩放
-->
```

#### 1.4. 块与行内元素
标准文档流里面，块级元素：
`div  , p  , form,   ul,  li ,  ol, dl, h1-h6,   address,  fieldset,  hr, menu,  table`
* 总是在新行上开始，占据一整行；
* 高度，行高以及外边距和内边距都可控制；
* 默认宽度填满父元素宽度，与内容无关；
* 它可以容纳内联元素和其他块元素。

**行内元素：**
`span,   strong,   em,  br,  img ,  input,  label,  select,  textarea,  cite`
* 和其他元素都在一行上；
* 高，行高及外边距和内边距部分可改变；
* 宽度只与内容有关；
* 行内元素只能容纳文本或者其他行内元素。
* 不可以设置宽高，其宽度随着内容增加，高度随字体大小而改变
* 内联元素可以设置外边界，水平方向起作用，竖直方向无作用

**replaced  和 non-replaced**
默认具有 CSS 格式化外表范围的元素，比如 img 元素，有自己的宽和高
`input，textarea，select`

#### 1.5. iframe的优缺点？
**优点：**
1. 解决加载缓慢的第三方内容如图标和广告等的加载问题
2. Security sandbox
3. 并行加载脚本
4. 方便页面的部分修改
5. 重载时减少数据传输

**缺点：**
1. iframe会阻塞主页面的Onload事件
2. 即时内容为空，加载也需要时间
3. 没有语意，不利于SEO，搜索引擎不容易解读
4. 浏览器后退无效
5. IFRAME销毁是无法全部释放内存，容易导致内存泄漏

如果需要使用 iframe ，最好是通过 javascript动态给iframe添加 src 属性值
**可用 Ajax 代替iframe** 

#### 1.6. 浏览器内多个标签页之间的通信
> sessionStorage 和 localStorage 是 HTML5 Web Storage API 提供的，可以方便的在 web 请求之间保存数据。有了本地数据，就可以避免数据在浏览器和服务器间不必要地来回传递

**通信方式：**
* localStorge & sessionStorage
    > 利用了 localStorage 的增删改事件监听

    sessionStorage 是在同源的同窗口（或 tab ）中，始终存在的数据。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后， sessionStorage 即被销毁。同时“独立”打开的不同窗口，即使是同一页面

    ```js
    //页面A发送事件
    function sendMsg(text) {
        window.localStorage.setItem('msg',text);
    }

    //页面B接收事件 (localstorage 被添加、修改或删除时，它都会触发一个事件，可监听事件)
    window.addEventListener('storage', function (evt) {
        if(evt.key==='msg')
        console.log(evt.newValue);
    });

    //需要注意的是重复设置相同的键值不会再次触发事件
    ```
    **localstorage不能存对象。 如果传递对象就先转成字符串。 然后取值的时候再转成对象。**

* cookie+setInterval
    > 将要传递的信息存储在cookie里面，然后每隔一定时间读取cookie信息来实现

    ```js
    //a页面
    var mess=document.getElementById("butOk").value();    
    document.cookie="mess="+mess;
    //b页面
    //获取Cookie天的内容  
    function getKey(key) {  
        return JSON.parse("{\""+ document.cookie.replace(/;\s+/gim,"\",\"").replace(/=/gim, "\":\"") +"\"}")[key];  
    }  
    //每隔1秒获取Cookie的内容  
    setInterval(function(){  
        console.log(getKey("mess"));  
    },1000); 
    ```

**特征**
* Cookie
    - 每个域名存储量比较小（各浏览器不同，大致 4K ）
    - 所有域名的存储量有限制（各浏览器不同，大致 4K ）
    - 有个数限制（各浏览器不同）
    - 会随请求发送到服务器

* LocalStorage
    - 永久存储
    - 单个域名存储量比较大（推荐 5MB ，各浏览器不同）
    - 总体数量无限制

* SessionStorage
    - 只在 Session 内有效
    - 存储量更大（推荐没有限制，但是实际上各浏览器也不同）

#### 1.7. `data-`属性的作用是什么
`data-`为H5新增的为前端开发者提供自定义的属性，这些属性集可以通过对象的 `dataset` 属性获取，不支持该属性的浏览器可以通过 `getAttribute` 方法获取 :


需要注意的是：`data-`之后的以连字符分割的多个单词组成的属性，获取的时候使用驼峰风格。 所有主流浏览器都支持 data-* 属性。
即：当没有合适的属性和元素时，自定义的 data 属性是能够存储页面或 App 的私有的自定义数据。

#### 1.8. 浏览器内核
主要分成两部分：
* 渲染引擎(layout engineer或 Rendering Engine)：
    负责取得网页的内容（HTML、 XML 、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。

* JS引擎则：
    解析和执行 javascript 来实现网页的动态效果。

最开始渲染引擎和JS引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。
浏览器 | 内核 | 前缀 | js 引擎
- | :-: | -:  | -: 
IE(360, 搜狗浏览器) | Trident | -ms- | Chakra
Chrome | Webkit | -webkit- | V8 
Safari | Webkit | -webkit- | Javascriptcore
Opera | Presto | -o- | Carakan
FireFox | gecko | -moz- |

#### 1.9. src && href
* src
    - 用于替换当前元素
    - src是 source 的缩写，指向外部资源的位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内
    例如 js 脚本， img 图片和 frame 等元素
    - `<script src ='js.js'></script>`
    当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕，图片和框架等元素也如此，类似于将所指向资源嵌入当前标签内。这也是为什么将js脚本放在底部而不是头部。
    
* href 
    - 用于在当前文档和引用资源之间确立联系
    - href是 Hypertext Reference 的缩写，指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接
    如果我们在文档中添加 `<link href='common.css' rel='stylesheet'/>`
    那么浏览器会识别该文档为css文件，就会并行下载资源并且不会停止对当前文档的处理。这也是为什么建议使用 link 方式来加载 css ，而不是使用 @import 方式。

## 2. CSS
#### 2.1. CSS3有哪些新特性
1. CSS3实现圆角（border-radius），阴影（box-shadow），
2. 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
3. transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜
4. 增加了更多的CSS选择器  多背景 rgba
5. 在CSS3中唯一引入的伪类是 ::selection.
6. 媒体查询，多栏布局
7. border-image

#### 2.2. CSS中 使用方式及其区别？
1. 内联式
    直接用在标签上，维护成本高
2. 样式块
    页面较为清晰，但不能被其他页面使用
3. 外链式 -link
    XHTML标签。css，html代码分离，便于代码重复使用
4. 外部导入式-import
    CSS标签。可以在一个样式块中导入多个样式表，类似外链

**link import区别**
* link属于 XHTML 标签，除了加载CSS外，还可以定义RSS等其他事务；而 @import 是 CSS 提供的,只能加载CSS
* 页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载
* link是html标签，因此没有兼容性，而@import只有IE5以上才能识别
* link方式样式的权重高于@import的

更多： [link 与 @import之对比](http://www.cnblogs.com/chaoran/p/4783933.html)

#### 2.3. FOUC（无样式内容闪烁）
>FOUC - Flash Of Unstyled Content 文档样式闪烁

```html
<style type="text/css" media="all">@import "../fouc.css";</style> 
```

引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。
解决方法: 
* 用 link 代替 @import
* 在 head 之间加入一个 link 或者 script 元素

#### 2.4. 盒模型
* 盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)
* 有两种， IE 盒子模型、标准 W3C 盒子模型；IE的content部分包含了 border 和 padding;

#### 2.5. CSS 选择符及其优先级
**CSS 选择符：**
1. id选择器(# myid)
2. 类选择器(.myclassname)
3. 标签选择器(div, h1, p)
4. 相邻选择器(h1 + p)
5. 子选择器(ul > li)
6. 后代选择器(li a)
7. 通配符选择器( * )
8. 属性选择器(a[rel = "external"])
9. 伪类选择器(a: hover, li:nth-child)

**可继承的样式：**
1. font-size
2. font-family
3. color
4. text-indent

**不可继承的样式：**
1. border
2. padding
3. margin
4. width
5. height

**优先级算法：**
1. 优先级就近原则，同权重情况下样式定义最近者为准;
2. 载入样式以最后载入的定位为准;
3. !important >  id > class > tag  > *
4. important > 内联 > id 

**CSS3新增伪类举例：**
* [p:first-of-type](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:first-of-type) 选择属于其父元素的首个 <p> 元素的每个 <p> 元素。
* p:last-of-type  选择属于其父元素的最后 <p> 元素的每个 <p> 元素。
* p:only-of-type  选择属于其父元素唯一的 <p> 元素的每个 <p> 元素。
* p:only-child    选择属于其父元素的唯一子元素的每个 <p> 元素。
* p:nth-child(2)  选择属于其父元素的第二个子元素的每个 <p> 元素。
* :enabled :disabled 控制表单控件的禁用状态。
* :checked        单选框或复选框被选中。

#### 2.6. position的absolute与fixed
**共同点：**
* 改变行内元素的呈现方式，display被置为inline-block；
* 让元素脱离普通流，不占据空间；
* 默认会覆盖到非定位元素上

**不同点：**
* absolute的根元素是可以设置的，而fixed的根元素固定为浏览器窗口。
* 当你滚动网页，fixed元素与浏览器窗口之间的距离是不变的。

**relative：**
* 生成相对定位的元素，相对于其正常位置进行定位。
* 元素的位置通过left、right、top、bottom属性进行规定，
* 可以通过z-index进行层次分级。
* 元素元素仍保持其未定位前的形状，原本所占的空间仍将保留。
* 如果没有定位偏移量，对元素本身没有任何影响

**absolute：**
* 生成绝对定位元素，脱离文档流，并相对于其包含块进行定位
* 所占的空间会会被后面元素占据；
* 元素定位后生成一个块级框，而不论原来它在正常流中生成何种类型的框；
* 绝对定位元素的包含块由离它最近的 'position' 属性为 'absolute'、'relative' 或者 'fixed' 的祖先元素创建。如果没有定义，那么就相对于整个文档body定位（注意不是相对于浏览器窗口定位）
* 相对定位一般都是配合绝对定位元素使用

**fixed：**
* 生成绝对定位元素，相对于浏览器窗口的定位
* 通常配合z-index一起来使用。
* 比如说网页上悬挂的聊天图标或者广告就是用了fixed

#### 2.7. display
![display](/img/in-post/post-web-nowcoder/display.png)
display 值的作用：
1. block 象块类型元素一样显示。
2. inline 缺省值。象行内元素类型一样显示。
3. inline-block 象行内元素一样显示，但其内容象块类型元素一样显示。
4. list-item 象块类型元素一样显示，并添加样式列表标记。

#### 2.8. display:none和visibility:hidden
* display:none  隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。
* visibility:hidden  隐藏对应的元素，但是在文档布局中仍保留原来的空间。

#### 2.9. position 值的定位区别
* absolute 生成绝对定位的元素，相对于 static 定位以外的第一个祖先元素进行定位。
* fixed 生成固定定位的元素，相对于浏览器窗口进行定位（老IE不支持）。
* relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。
* static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。
* inherit 规定从父元素继承 position 属性的值。

#### 垂直水平居中
* **水平或垂直居中**
    - 单行内容垂直居中
    - div水平居中
    - float
* **水平+垂直居中**
    - 非固定高度居中
    - 利用表格
    - margin负值
    - 完全居中
    - fixed（可视区域内居中）
    - transform
    - inline-block
    - Flex方法
* **图片居中**
    - align
    - text-align

更多了解：[CSS 居中](http://www.cnblogs.com/chaoran/p/7061932.html)

#### 2.10. 怪异模式
> 为了在那些针对 HTML5 设计，但是又没有添加 doctype(可以决定浏览器工作在哪种模式下，后面会详细讨论)的页面而存在

浏览器 | 内核 | 前缀 | js 引擎
- | :-: | -:  | -: 
IE | Trident | -ms- | Chakra
Chrome | Webkit | -webkit- | V8 
Safari | Webkit | -webkit- | Javascriptcore
Opera | Presto | -o- | Carakan
FireFox | gecko | -moz- | 


IE6 时，渲染引擎（MSHTML.dll）做出了一个重要的改变，将自己原先不符合 W3C 规范中的盒模型 box mode 绘制方式改为与 W3C 标准一致（后面会详细讨论），由于这个重大的改动，原先针对 IE 旧版本所设计的 HTML 页面都不能正确显示了，所以在 IE6 发布的时候附带了一个切换回 IE5 页面渲染方式的功能，这个功能中就首次提出了 Quirks Mode。

当用户需要显示旧版本的页面时切换到 Quirks Mode，这时浏览器的渲染引擎就切换到 IE5.5 所对应的版本(MSHTML.dll 5.5.x)，box mode 还是按照之前的方式绘制

当用户需要显示一些新的、满足 W3C 规范的页面时，渲染引擎切换到一个与 Quirks Mode 对应的 Standards Mode（标准模式）

**浏览器如何判断文档类型**
1. Doctype 检测
当 doctype 为<!DOCTYPE html>，表明该页面是遵守了 HTML5 规范的，浏览器会选择 Standards Mode
当 doctype 缺失的时候，浏览器会选择 Quirks Mode

2. x-ua-compatible 信息
![meta](/img/in-post/post-web-nowcoder/meta.png)

**标准模式下的页面与怪异模式下的页面区别**
1. 盒模型
开发人员描述 CSS 中块级元素的一种约定俗称
![box-ie](/img/in-post/post-web-nowcoder/box-ie.png)
![box-standard](/img/in-post/post-web-nowcoder/box-stan.png)

2. 图片元素的垂直对齐方式
vertical-align：定义行内元素的 base line 相对于该元素所在行的 base line 的垂直对齐
    `baseline，sub，supper，top，text-top，bottom，text-bottom，middle `
    base line 指的是一行字横排时下沿的基础线，baseline 并不是汉字的下端沿，而是英文字母 e 的下端沿，bottom line，指的是汉字，或者英文字母 p，g 的下端沿。
    * 对于 inline 元素和 table-cell 元素，在 IE Standards Mode 下 vertical-align 属性默认取值为 baseline。而当 inline 元素的内容只有图片时，如 table 的单元格 table-cell。在 IE Quirks Mode 下，table 单元格中的图片的 vertical align 属性默认为 bottom，因此，在图片底部会有几像素的空间
3. table 元素中的字体
 IE Quirks Mode 下，对于 table 元素，字体的某些属性将不会从 body 或其他封闭元素继承到 table 中，特别是 font-size 属性。
4. 内联元素的尺寸
IE Standards Mode 下，non-replaced inline 元素无法自定义大小，而在 IE Quirks Mode 下，定义这些元素的 width 和 height 属性，能够影响该元素显示的大小尺寸。
5. 元素的百分比高度
 IE Standards Mode 下，高度取决于内容的变化，而在 Quirks Mode 下，百分比高度则被正确应用。
6. 元素溢出的处理
IE Standard Mode 下，overflow 取默认值 visible，即溢出可见，这种情况下，溢出内容不会被裁剪，呈现在元素框外。而在 Quirks Mode 下，该溢出被当做扩展 box 来对待，即元素的大小由其内容决定，溢出不会被裁剪，元素框自动调整，包含溢出内容

#### 2.11. CSS reset
> 是否使用，取决于 “是否需要依赖浏览器默认样式”

1. 导致blockquote、ol、ul、hn等语义元素在没有赋以其他合理的样式时（常常如此），缺乏恰当的样式展现。而因为视觉上无法区分，这进一步导致许多开发人员忽视或误用这些语义元素
2.  CSS reset 通常会增加浏览器进行样式计算的成本（即有一定的性能负担）

#### 2.12. html常见兼容性问题
1. png24位的图片在iE6浏览器上出现背景
    解决方案：做成PNG8，也可以引用一段脚本处理.

2. 浏览器默认的margin和padding不同
    解决方案：加一个全局的 *{margin:0;padding:0;} 来统一。

3. IE6双边距bug：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。
`#box{ float:left; width:10px; margin:0 0 0 10px;} `
这种情况之下IE会产生20px的距离
解决方案：在float的标签样式控制中加入 _display:inline; 将其转化为行内属性。( _ 这个符号只有ie6会识别)

4. 渐进识别的方式，从总体中逐渐排除局部。 
首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。 
接着，再次使用 "+" 将IE8和IE7、IE6分离开来，这样IE8已经独立识别。
    ```js
    .bb{
        background-color:#f1ee18; /*所有识别*/
        .background-color:#00deff\9; /*IE6、7、8识别*/
        +background-color:#a200ff; /*IE6、7识别*/
        _background-color:#1e0bd1; /*IE6识别*/ 
    } 
    ```

5. IE下，可以使用获取常规属性的方法来获取自定义属性，也可以使用 getAttribute() 获取自定义属性；Firefox下,只能使用getAttribute()获取自定义属性
解决方法：统一通过getAttribute()获取自定义属性

6. IE下，event对象有 x、y 属性，但是没有 pageX、pageY属性; Firefox下，event对象有 pageX、pageY 属性，但是没有 x、y 属性
解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。

7. Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示
解决方法：可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决

8. 超链接访问过后 hover 样式就不出现了，被点击访问过的超链接样式不在具有 hover 和 active 了
解决方法：改变CSS属性的排列顺序 L-V-H-A
    ```css
    a:link {}
    a:visited {}
    a:hover {}
    a:active {}
    ```

9. 怪异模式问题：漏写 DTD 声明，Firefox 仍然会按照标准模式来解析网页，但在 IE 中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写 DTD 声明的好习惯。现在可以使用[html5](http://www.w3.org/TR/html5/single-page.html) 推荐的写法：<!DOCTYPE html>

10. 上下margin重合问题：ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。
解决方法：养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。

11. ie6对png图片格式支持不好
解决方案：引用一段脚本处理

12. li之间有间距
解决方法：li 设置vertical-align:middle;

#### 2.13. 适配 & CSS 中的单位
假定已经存在一个使用px单位，且完全适配320xp宽度手机的页面
1. 改变viewport的initial-scale的数值
首屏渲染 -> js改变initial-scale -> 二次渲染，页面放大(闪烁)
得提前知道所适配的设备的尺寸,然后服务端根据userAgent来判断。
    ```html
    <% if(device === 1){ %>
        <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=2.0,user-scalable=no" />
    <% } %>

    <% if(device === 2){ %>
        <meta name="viewport" content="width=device-width,initial-scale=1.5,maximum-scale=2.0,user-scalable=no" />
    <% } %>
    ```
    或者使用js计算缩放比例 ,然后替换initial-scale的值
    ```js
    var scale =  screen.width/320,
        viewport =  document.querySelector('meta[name=viewport]');
        
    viewport.setAttribute('content',
        viewport.getAttribute('content')
                .replace(/(initial-scale)=[\d\.]?\d/,'$1='+scale))    
    ```

    使用js会有滞后性，页面会多渲染一次，且会导致页面闪烁
    > 首屏渲染 -> js改变initial-scale -> 二次渲染，页面放大(闪烁)

2. 替换px转而使用rem


**单位大体分为两大类：**
* 绝对单位 ，不会因为其他元素的尺寸变化而变化。
* 相对单位 ，没有一个固定的度量值，而是由其他元素尺寸来决定的相对值。


类型 | 简介 | 类型	
- | :-: | -:  | -: 
px | 像素 (计算机屏幕上的一个点)，1px = 1/96in | absolute
pt | Points, 1pt = 1/72in
pc | Picas, 1pc = 12pt
in | Inches, 1in = 96px = 2.54cm
cm | Centimeters, 1cm = 96/2.54px
mm | Millimeters, 1mm = 1/10cm
q |	Quarter-millimeters, 1q = 1/4mm
% |	相对于父元素的宽度或字体大小 | relative
em | 相对于父元素的字体大小
rem | (即root em) 相对于html标签的字体大小
ex | 当前字体环境中 x 字母的高度
ch | 当前字体环境中 0 数字的高度
vw | 1% 视口（浏览器可视区域）的宽度
vh | 1% 视口（浏览器可视区域）的高度
vmin | 1% 视口（浏览器可视区域）的宽度和高度中较小的尺寸
vmax | 1% 视口（浏览器可视区域）的宽度和高度中较大的尺寸

相对单位：
* %
    > 相对于父元素的相同属性的大小
    - 参照父元素宽度的元素：padding margin width text-indent
    - 参照父元素高度的元素：height
    - 参照父元素属性:font-size   line-height
    -  **特殊**：
        - 相对定位的时候，top(bottom)   left(right)参照的是父元素的 content-box
        - 绝对定位的时候参照的是最近的定位元素 padding-box

* em && rem
    两者都是基于字体尺寸的，区别在于 em 是相对于当前父元素的字体大小为标准，而 rem 是相对于 html 元素的字体大小为标准。
* ex && ch
    ex 和ch 单位，依赖于当前字体 font-family 和字体大小 font-size。 ex 指当前字体环境中小写字母x 的高度，ch 指当前字体环境中数字 0 的宽度。
![ex](/img/in-post/post-web-nowcoder/ex.jpg)
* vw && vh
    > vh 等于视窗高度的 1/100.

    “视区”所指为浏览器内部的可视区域大小，即window.innerWidth/window.innerHeight大小，不包含任务栏标题栏以及底部工具栏的浏览器区域大小。

    例如，如果浏览器的高是 900px, 1vh 求得的值为 9px 。同理，如果显示窗口宽度为 750px, 1vw 求得的值为 7.5px。
    **应用场景**
    * 元素的尺寸限制
        ```css
        img { max-height: 90vh; }
        ```
    * 视区覆盖以及边界定位
        ```css
        </* 弹出框的半透明覆盖层 */>
        .dialog_container {
            width: 100%;
            width: 100vw;
            height: 100%;
            height: 100vh;
            background-color: rgba(0,0,0,.35);
            position: fixed;
            top: 0;
            left: 0;
        }
        ```
    * 滚动条跳动
        ```css
        .wrap-outer {
            margin-left: calc(100vw - 100%);
        }

        /* 或者： */
        .wrap-outer {
            padding-left: calc(100vw - 100%);
        }
        ```
        100vw相对于浏览器的window.innerWidth，是浏览器的内部宽度，注意，滚动条宽度也计算在内！而100%是可用宽度，是不含滚动条的宽度。
        于是，calc(100vw - 100%)就是浏览器滚动条的宽度大小

        vw, vh视区大小相关单位只适用于非定位元素的高度相关属性上！ (高度相关属性如 –`height/min-height/max-height/line-height/padding-top/padding-bottom` 等)

参考： 
[CSS 单位](https://segmentfault.com/a/1190000004043937)
[视区相关单位vw, vh..简介以及可实际应用场景](http://www.zhangxinxu.com/wordpress/2012/09/new-viewport-relative-units-vw-vh-vm-vmin/)

## 3. JavaScript
#### 3.1. JavaScript 的同源策略
> 同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载

这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。

**为什么要有同源限制：**
比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。

#### 3.2. use strict
> ECMAscript 5添加了第二种运行模式："严格模式"（strict mode）。顾名思义，这种模式使得Javascript在更严格的条件下运行

设立"严格模式"的目的，主要有以下几个：
1. 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;
2. 消除代码运行的一些不安全之处，保证代码运行的安全；
3. 提高编译器效率，增加运行速度；
4. 为未来新版本的Javascript做好铺垫。
注：经过测试 IE6,7,8,9 均不支持严格模式。

**缺点：**
现在网站的 JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。

#### 3.3. WebSocket && 消息推送
> HTTP 协议缺陷：通信只能由客户端发起

**解决方法：双向通信与消息推送**
* 轮询：客户端**定时向服务器发送Ajax请求**，服务器接到请求后马上返回响应信息并关闭连接。 
    - 优点：后端程序编写比较容易。 
    - 缺点：请求中有大半是无用，浪费带宽和服务器资源。 
    - 实例：适于小型应用。

* 长轮询：客户端向服务器发送Ajax请求，服务器接到请求后 **hold 住连接**，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 
    - 优点：在无消息的情况下不会频繁的请求，耗费资小。 
    - 缺点：服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。 Comet 异步的 ashx ， 
    - 实例：WebQQ、 Hi 网页版、 Facebook IM 。

* 长连接：在页面里嵌入一个隐蔵iframe，将这个隐蔵 iframe 的 src 属性设为对一个长连接的请求或是采用 xhr 请求，服务器端就能源源不断地往客户端输入数据。 
    - 优点：消息即时到达，不发无用请求；管理起来也相对方便。 
    - 缺点：服务器维护一个长连接会增加开销。 
    - 实例：Gmail聊天

* Flash Socket：在页面中内嵌入一个使用了 Socket 类的 Flash 程序 JavaScript 通过调用此 Flash 程序提供的 Socket 接口与服务器端的 Socket 接口进行通信， JavaScript 在收到服务器端传送的信息后控制页面的显示。 
    - 优点：实现真正的即时通信，而不是伪即时。 
    - 缺点：客户端必须安装Flash插件；非 HTTP 协议，无法自动穿越防火墙。 
    - 实例：网络互动游戏。

* WebSocket是 HTML5 开始提供的一种浏览器与服务器间进行全双工通讯的网络技术。依靠这种技术可以实现客户端和服务器端的长连接，双向实时通信。
    - 主要特点:
        - 事件驱动
        - 异步
        - 使用 ws 或者 wss 协议的客户端 socket
        - 能够实现真正意义上的推送功能
    - 缺点：少部分浏览器不支持，浏览器支持的程度与方式有区别。

**webSocket 特点：**
* 服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于**服务器推送**技术的一种
* 建立在 TCP 协议之上，服务器端的实现比较容易。
* 与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。
* 数据格式比较轻量，性能开销小，通信高效。
* 可以发送文本，也可以发送二进制数据。
* 没有同源限制，客户端可以与任意服务器通信。
* 协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。

**webSocket.readyState**
readyState属性返回实例对象的当前状态，共有四种:
* CONNECTING：值为0，表示正在连接。
* OPEN：值为1，表示连接成功，可以通信了。
* CLOSING：值为2，表示连接正在关闭。
* CLOSED：值为3，表示连接已经关闭，或者打开连接失败。

#### 3.4. null和undefined
* null 是一个表示"无"的对象，转为数值时为0
* undefined 是一个表示"无"的原始值，转为数值时为NaN
* 当声明的变量还未被初始化时，变量的默认值为undefined
* null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象

undefined表示 “缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：
1. 变量被声明了，但没有赋值时，就等于 undefined
2. 调用函数时，应该提供的参数没有提供，该参数等于 undefined
3. 对象没有赋值的属性，该属性的值为 undefined
4. 函数没有返回值时，默认返回 undefined

null表示“没有对象”，即该处不应该有值。典型用法是：
1. 作为函数的参数，表示该函数的参数不是对象
2. 作为对象原型链的终点

#### 3.5. new操作符具体干了什么
1. 创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型
2. 属性和方法被加入到 this 引用的对象中
3. 新创建的对象由 this 所引用，并且最后隐式的返回 this

    ```js
    var obj  = {};
    obj.__proto__ = Base.prototype;
    Base.call(obj); 
    ```

#### 3.6. JSON
JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小。
```json
{"age":"12", "name":"back"}
```

#### 3.7. js延迟加载
方法：
1. defer和async
    差别在于脚本下载完之后何时执行
    * async
        加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步），不考虑依赖关系
    * **defer**--常用
        `<script async src="script.js"></script>`
        加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在**所有元素解析完成**之后，DOMContentLoaded 事件触发之前完成。
        **按照加载顺序执行脚本**
2. 动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）
    ```js
    function loadScript(url, callback){
        var script = document.createElement ("script")
        script.type = "text/javascript";
        if (script.readyState){ //IE
            script.onreadystatechange = function(){
                if (script.readyState == "loaded" || script.readyState == "complete"){
                    script.onreadystatechange = null;
                    callback();
                }
            };
        } else { //Others
            script.onload = function(){
                callback();
            };
        }
        script.src = url;
        document.getElementsByTagName_r("head")[0].appendChild(script);
    }
    ```

3. 按需异步载入js
4. 放到最后加载

#### 3.8. documen.write和 innerHTML 
* document.write 只能重绘整个页面
* innerHTML 可以重绘页面的一部分

#### 3.9. 内存泄漏
> 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在

垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。

导致原因：
1. setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。
2. 闭包
3. 控制台日志
4. 循环（在两个对象彼此引用且彼此保留时，就会产生一个循环）

#### 3.10. 判断当前脚本运行在浏览器还是node环境
通过判断 Global 对象是否为window，如果不为window，当前脚本没有运行在浏览器中。
* 在node中的全局变量是global 
* 浏览器的全局变量是window

可以通过该全局变量是否定义来判断宿主环境

#### 3.11. Node的优点和缺点
> 在Node中）除了代码，一切都是并行的！

特点：单线程、异步I/O、事件驱动
事件驱动：
* 通过事件或状态的变化来进行应用程序的流程控制
* 当执行过程中遇到I/O阻塞(读取文件、查询数据库、请求套接字、访问远程服务等)时，事件循环线程不会停下等待结果,转而继续执行队列中的下一个任务,不会在事件循环线程中执行

NodeJS的事件循环模型一般要注意下面几点：
* 因为是单线程的，所以当顺序执行js文件中的代码的时候，事件循环是被暂停的
* 当JS文件执行完以后，事件循环开始运行，并从消息队列中取出消息，开始执行回调函数
* 因为是单线程的，所以当回调函数被执行的时候，事件循环是被暂停的
* 当涉及到I/O的时候，nodejs会开一个独立的线程来进行异步I/O操作，操作结果以后将消息压入消息队列

**优点：**
1. 因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求，因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。
2. 与Node代理服务器交互的客户端代码是由javascript语言编写的，因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。

**缺点：**
1. Node是一个相对新的开源项目，所以不太稳定，它总是一直在变。
2. 缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子（第三方库现在已经很丰富了，所以这个缺点可以说不存在了）。

**Node.js 的适用场景:**
1. 高并发
2. 聊天
3. 实时消息推送   

#### 3.12. javascript 创建对象
1. Object构造函数创建
    ```js
    var Person = new Object();
    Person.name = 'Nike';
    Person.age = 29;
    //创建了Object引用类型的一个新实例，然后把实例保存在变量Person中
    ```

2. 对象字面量表示法
    ```js
    var Person = {};//相当于var Person = new Object();
    var Person = {
        name:'Nike';
        age:29;  
    }
    ```
    对象字面量是对象定义的一种简写形式，目的在于简化创建包含大量属性的对象的过程。
    也就是说，第一种和第二种方式创建对象的方法其实都是一样的，只是写法上的区别不同

    避免过多的重复代码

3. 工厂模式
    ```js
    function createPerson(name,age,job){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName = function(){
            alert(this.name); 
        };
        return o; 
    }
    var person1 = createPerson('Nike',29,'teacher');
    var person2 = createPerson('Arvin',20,'student');
    ```
    createPerson函数中，返回的是一个对象。我们无法判断返回的对象究竟是一个什么样的类型

4. 使用构造函数创建对象
    ```js
    function Person(name,age,job){
        this.name = name;
        this.age = age;
        this.job = job;
        this.sayName = function(){
            alert(this.name);
        }; 
    }
    var person1 = new Person('Nike',29,'teacher');
    var person2 = new Person('Arvin',20,'student');
    ```

    **new**
    * 创建了一个对象
    * 将this指向这个对象
    * 返回这个对象
    * 实例对象都有一个属性constructor(构造函数)，指向Person
    可以通过constructor判断对象类型的原理
    
    **对比工厂模式，我们可以发现以下区别：**
    * 没有显示地创建对象
    * 直接将属性和方法赋给了this对象
    * 没有return语句
    * 终于可以识别的对象的类型。对于检测对象类型，我们应该使用instanceof操作符
    * 按照惯例，构造函数始终要应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头

    **构造函数缺点：**
    每个方法都要在每个实例上重新创建一遍，方法指的就是我们在对象里面定义的函数。如果方法的数量很多，就会占用很多不必要的内存

5. 原型创建对象模式
    > 与构造函数模式不同的是，原型模式的每个实例都是访问同一属性同一函数，函数不用重新创建

    ```js
    function Person(){}
        Person.prototype.name = 'Nike';
        Person.prototype.age = 20;
        Person.prototype.jbo = 'teacher';
        Person.prototype.sayName = function(){
        alert(this.name);
    };
    var person1 = new Person();
    var person2 = new Person();
    person1.name ='Greg';
    alert(person1.name); //'Greg' --来自实例
    alert(person2.name); //'Nike' --来自原型
    ```
    * 使用原型创建对象的方式，可以让所有对象实例共享它所包含的属性和方法。
    * 当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的同名属性。
    * 这时候我们就可以使用构造函数模式与原型模式结合的方式，构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性

6. 组合使用构造函数模式和原型模式
    ```js
    function Person(name,age,job){
        this.name =name;
        this.age = age;
        this.job = job;
    }
    Person.prototype = {
        constructor:Person,
        sayName: function(){
            alert(this.name);
        };
    }
    var person1 = new Person('Nike',20,'teacher');
    ```

#### 3.13. javascript 继承
1. 原型链
基本思想：利用原型让一个引用类型继承另外一个引用类型的属性和方法。
构造函数，原型，实例之间的关系：
    * 每个构造函数都有一个原型对象
    * 原型对象包含一个指向构造函数的指针
    * 实例都包含一个指向原型对象的内部指针。
    ```js
    SubType.prototype = new SuperType();//继承了SuperType
    ```
2. 构造函数
基本思想：在子类型构造函数的内部调用超类构造函数，通过使用call()和apply()方法可以在新创建的对象上执行构造函数。
    ```js
    function SubType() {
        SuperType.call(this);//继承了SuperType
    }
    ```
3. 组合继承
基本思想：将原型链和借用构造函数的技术组合在一块，从而发挥两者之长的一种继承模式。
4. 原型式继承
基本想法：借助原型可以基于已有的对象创建新对象，同时还不必须因此创建自定义的类型
    ```js
    function object(o) {
        function F() {}
        F.prototype = o;
        return new F();
    }
    ```
5. 寄生式继承
基本思想：创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真正是它做了所有工作一样返回对象。 
6. 寄生组合式继承
基本思想：通过借用函数来继承属性，通过原型链的混成形式来继承方法 
    ```js
    function inheritProperty(subType, superType) {
        var prototype = object(superType.prototype); //创建对象
        prototype.constructor = subType; //增强对象
        subType.prototype = prototype; //指定对象
    }
    ```

#### 3.14. 原型与原型链
* 原型对象
    - 每个函数对象都有一个prototype 属性，这个属性指向函数的原型对象
    - 原型上的属性和方法都是共有的
    - prototype这个对象上，自带一个属性，constructor指向当前这个类
    - 原型对象（Person.prototype）是 构造函数（Person）的一个实例
    **注意：**
        - 添加和修改原型的属性和方法都能立即在所有对象实例中反应出来（即使先创建实例后修改原型）
        - 但是如果重写整个原型对象，创建在前的实例并不能获得重写后的属性或方法
        这是因为重写原型之后是新生成原型对象，和声明在前的任何已经存在的实例都没有关系。
* 原型链
> 原型链是由一些用来继承和共享属性的对象组成的（有限的）对象链

    每个对象数据类型（普通对象，prototype，实例）都有一个属性，叫做 __proto__
    __proto__指针 指向构造函数的 prototype
    `person1.__proto__ == Person.prototype`
![prototype](/img/in-post/post-web-nowcoder/prototype.jpg)

console.log（Tom.age）的查找过程
1. 首先在私有空间内查找age属性，私有空间的属性包括自身的属性和从类那里继承的属性
2. 找不到的话：通过__proto__去当前实例所属类的原型上进行查找，找到的话，说明是共有属性；
3. 还找不到的话：继续通过__proto__去当前实例所属类的原型进行查找，找不到将继续通过__proto__一直找到Object。 

原型和原型链是JS实现继承的一种模型。
原型链的形成是真正是靠__proto__ 而非prototype


更多：
* [JS之理解原型和原型链](https://segmentfault.com/a/1190000010354583)
* [最详尽的 JS 原型与原型链终极详解](https://www.jianshu.com/p/dee9f8b14771)

#### 3.15. ajax 过程
1. 创建XMLHttpRequest对象,也就是创建一个异步调用对象
2. 创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息
3. 设置响应HTTP请求状态变化的函数
4. 发送HTTP请求
5. 获取异步调用返回的数据
6. 使用JavaScript和DOM实现局部刷新

#### 3.16. `setTimeout` & `this` & `setInterval`
**setTimeout this**
> 超时调用的代码都是在全局作用域中执行的，因此函数中的this的值在非严格模式下指向window对象，在严格模式下是undefined

![mvc](/img/in-post/post-web-fragment/this.jpg)
* setTimeout()中，如果是setTimeout(this)这样的形式，那么this要看上下文，默认是window；
* 如果setTimeout里面的函数中的this的话，都统一指向window
* 第14行代码的this是指向test1对象的，那只要我们保存一下这个变量，然后使用闭包就能获取到它了，因为闭包可以保存自身当前作用域上的变量（当然这肯定是耗费内存的）
    ```js
    function test1() {
        var _this = this; 
        this.name = "chaoran";
        this.sayName = function() {
            console.log(this.name);
        }
        setTimeout(function () {
            // 由于闭包的原因保存了_this为test1对象，所以sayName()输出“chaoran”
            _this.sayName();     
            },0);
        }
    new test1();
    ```

**事件添加**
> 定时器对队列的工作方式：当特定时间过去后将代码添加到队列中，但并不意味着会马上将执行，设定一个200ms后执行的定时器，指的是在200ms后它将被添加到队列中，是否执行，还得看队列中是否没有其他的东西

> 定时器的回调函数并不是相当于在时间到了就执行，而是有一个主js执行进程，这个进程是页面刚加载的时候页面按照加载顺序执行的js代码，此外还有一个需要在进程空闲的时候执行的代码队列

```js
var a=document.getElementById("nav");
    a.onclick=function(){
    setTimeout(alertsomething,200);
    //一些其他的代码
}
function alertsomething(){
    alert("it is working");
}
```
假定onclick处理程序需要执行300ms，这时虽然在205ms添加了定时器代码，但是仍旧需要等待onclick事件完成后才能够执行。如图所示，本来在205ms处添加了定时器代码，但是由于此时onclick事件还没结束，故要等到300ms后才执行定时器代码
![load-order1](/img/in-post/post-web-nowcoder/settimeout.png)

**为什么常用setTimeout模拟setInterval**
* setTimeout方法，在一个指定的时间间隔后运行代码。
    问题：定时器代码可能在代码再次被添加到队列之前还没有完成执行，结果导致定时器代码连续运行好几次，而之间没有任何停顿
* setInterval方法， 每隔一个固定的时间间隔后持续运行指定代码
    仅当没有该定时器的任何其他代码实例时，才将定时器代码添加到队列中。这确保了定时器代码加入到队列中的最小时间间隔为指定间隔，问题：
    - 某些间隔被跳过；
    - 多个定时器的代码执行之间的间隔可能比预期的小

**解决方法：**
> 重复定时器

```js
setTimeout(function(){
    //处理代码
    setTimeout(arguments.callee,interval)
},intercal);
```

**应用**
* 调整事件发生顺序
    网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，我们先让父元素的事件回调函数先发生，就要用到 `setTimeout(f, 0)`

更多了解：
* [理解 setTimeout 和 setInterval](https://www.cnblogs.com/xiaohuochai/p/5773183.html)
* [由 setTimeout 的 this 讲起](http://blog.csdn.net/qq_26598303/article/details/52668683)
    

## 4. 其他
#### 4.1. GET 和 POST
* 用途
    - get 是从服务器上获取数据
    - post 是向服务器传送数据。

* 参数传递方式
    - get 是把参数数据队列加到提交表单的 ACTION 属性所指的 URL 中，值和表单内各个字段一一对应，在 URL 中可以看到
    - post 是通过 HTTP post 机制，将表单内各个字段与其内容放置在 HTTP 的 body 内一起传送到 ACTION 属性所指的 URL 地址, 用户看不到这个过程。

* 参数获取方式
    - 对于 get 方式，服务器端用 Request.QueryString 获取变量的值
    - 对于 post 方式，服务器端用 Request.Form 获取提交的数据。

* 参数大小
    - get 传送的数据量较小，不能大于 2KB
    - post 传送的数据量较大，一般被默认为不受限制。但理论上， IIS4 中最大量为 80KB ， IIS5 中为 100KB 。

* get 安全性低， post 安全性较高。

在以下情况中，请使用 POST 请求：
1. 无法使用缓存文件（更新服务器上的文件或数据库）
2. 向服务器发送大量数据（POST 没有数据量限制）
3. 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

更多：[学习前端前必知的——HTTP协议详解](http://www.cnblogs.com/chaoran/p/4783633.html)

#### 4.2. 页面从输入 URL 到页面加载过程
分为4个步骤：
1. 当发送一个 URL 请求时，不管这个 URL 是 Web 页面的 URL 还是 Web 页面上每个资源的 URL，浏览器都会开启一个线程来处理这个请求，同时在远程 DNS 服务器上启动一个 DNS 查询。这能使浏览器获得请求对应的 IP 地址。
2. 浏览器与远程 Web 服务器通过 TCP 三次握手协商来建立一个 TCP/IP 连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。
3. 一旦 TCP/IP 连接建立，浏览器会通过该连接向远程服务器发送 HTTP 的 GET 请求。远程服务器找到资源并使用 HTTP 响应返回该资源，值为 200 的 HTTP 响应状态表示一个正确的响应。
4. 此时，Web 服务器提供资源服务，客户端开始下载资源。

请求返回后，便进入了我们关注的前端模块
简单来说，浏览器会解析 HTML 生成 DOM Tree，其次会根据 CSS 生成 CSS Rule Tree，而 javascript 又可以根据 DOM API 操作 DOM

更多：[从输入 URL 到页面加载完的过程中都发生了什么事情？](http://www.cnblogs.com/chaoran/p/4795642.html)

#### 4.3. 网站的文件和资源优化
1. 文件合并
2. 文件最小化/文件压缩
3. 使用 CDN 托管
4. 缓存的使用（多个域名来提供缓存）
5. 其他

测试代码性能
* Profiler
* JSPerf（http://jsperf.com/nexttick-vs-setzerotimeout-vs-settimeout）
* Dromaeo

更多：[网站性能优化](http://www.cnblogs.com/chaoran/p/4795800.html)

#### 4.4. 前端的安全问题
1. XSS (Cross Site Scripting) 跨站脚本攻击
    指攻击者在网页中嵌入客户端脚本(例如JavaScript), 当用户浏览此网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的.  比如获取用户的Cookie，导航到恶意网站,携带木马等
    * 将重要的cookie标记为http only, 这样的话Javascript 中的document.cookie语句就不能获取到cookie了.
    * 只允许用户输入我们期望的数据
    * 对数据进行Html Encode 处理
    * 过滤或移除特殊的Html标签
    * 过滤JavaScript 事件的标签。例如 "onclick=", "onfocus" 等等。
2. sql注入
3. CSRF：（Cross-site request forgery）跨站请求伪造
    核心是请求伪造，通过伪造身份提交POST和GET请求来进行跨域的攻击
    完成CSRF需要两个步骤：
    1. 登陆受信任的网站A，在本地生成 COOKIE
    2. 在不登出A的情况下，或者本地 COOKIE 没有过期的情况下，访问危险网站B。
    **防范：**
    * 杜绝用户的一切外链资源。需要站外图片，可以抓回后保存在站内服务器里。
    * 对于富文本内容，使用白名单策略，只允许特定的 CSS 属性。
    * 尽可能开启 Content Security Policy 配置，让浏览器底层来实现站外资源的拦截。
    * 采用POST请求,增加攻击的难度.用户点击一个链接就可以发起GET类型的请求。而POST请求相对比较难，攻击者往往需要借助javascript才能实现
    * 对请求进行认证，确保该请求确实是用户本人填写表单并提交的，而不是第三者伪造的.具体可以在会话中增加token,确保看到信息和提交信息的是同一个人

更多：[web 攻击](http://www.cnblogs.com/chaoran/p/6581024.html)

#### 4.5. css阻塞 && js阻塞
**页面加载：**
* 加载完静态资源后通过ajax请求去后台获取数据，数据回来后渲染内容
![load-order1](/img/in-post/post-web-nowcoder/load-order-1.png)
* 使用后台直出，返回的html已经带上内容了
![load-order2](/img/in-post/post-web-nowcoder/load-order-2.png)

1. DOM加载到link标签
    css文件的加载是与DOM的加载并行的，也就是说，css在加载时Dom还在继续加载构建，而过程中遇到的css样式或者img，则会向服务器发送一个请求，待资源返回后，将其添加到dom中的相对应位置中；

2. DOM加载到script标签
    由于js文件不会与DOM并行加载，因此需要等待js整个文件加载完之后才能继续DOM的加载，倘若js脚本文件过大，则可能导致浏览器页面显示滞后，出现“假死”状态，这种效应称之为“阻塞效应”；会导致出现非常不好的用户体验；

js阻塞其他资源的加载的原因是：**浏览器为了防止js修改DOM树，需要重新构建DOM树的情况出现**

**js 阻塞**
* 特性：
    > 所有浏览器在下载 JS 的时候，会阻止一切其他活动，比如其他资源的下载，内容的呈现等等。直到 JS 下载、解析、执行完毕后才开始继续并行下载其他资源并呈现内容。为了提高用户体验，新一代浏览器都支持并行下载 JS，但是 JS 下载仍然会阻塞其它资源的下载（例如.图片，css文件等）。

    - 由于浏览器为了防止出现 JS 修改 DOM 树，需要重新构建 DOM 树的情况，所以就会阻塞其他的下载和呈现。
    - 嵌入 JS 会阻塞所有内容的呈现
    - 外部 JS 只会阻塞其后内容的显示
    - 2 种方式都会阻塞其后资源的下载
    也就是说外部样式不会阻塞外部脚本的加载，但会阻塞外部脚本的执行。

**CSS 阻塞**
> CSS 本来是可以并行下载的，在什么情况下会出现阻塞加载了(在测试观察中，IE6 下 CSS 都是阻塞加载）

当 CSS 后面跟着嵌入的 JS 的时候，该 CSS 就会出现阻塞后面资源下载的情况。而当把嵌入 JS 放到 CSS 前面，就不会出现阻塞的情况了（css文件可以和body里的请求并行）。
根本原因：因为浏览器会维持 html 中 css 和 js 的顺序，样式表必须在嵌入的 JS 执行前先加载、解析完。而嵌入的 JS 会阻塞后面的资源加载，所以就会出现上面 CSS 阻塞下载的情况。

**嵌入JS应该放在什么位置？**
1. 放在底部，虽然放在底部照样会阻塞所有呈现，但不会阻塞资源下载。
2. 如果嵌入JS放在head中，请把嵌入JS放在CSS头部。
3. 使用 defer（只支持IE）
4. 不要在嵌入的JS中调用运行时间较长的函数，如果一定要用，可以用 setTimeout 来调用

**Javascript无阻塞加载具体方式：**
1. 将脚本放在底部。link 还是放在head中，用以保证在js加载前，能加载出正常显示的页面。script 标签放在 /body 前。
2. 阻塞脚本：由于每个 script 标签下载时阻塞页面解析过程，所以限制页面 script 总数也可以改善性能。适用于内联脚本和外部脚本。
3. 非阻塞脚本：等页面完成加载后，再加载js代码。也就是，在 window.onload 事件发出后开始下载代码。
4. defer属性：支持IE4和fierfox3.5更高版本浏览器
5. 动态脚本元素：文档对象模型（DOM）允许你使用js动态创建HTML的几乎全部文档内容。代码如下：
    ```js
    <script>
        var script=document.createElement("script");
        script.type="text/javascript";
        script.src="file.js";
        document.getElementsByTagName("head")[0].appendChild(script);
    </script>
    ```
    此技术的重点在于：无论在何处启动下载，文件额下载和运行都不会阻塞其他页面处理过程，即使在head里（除了用于下载文件的 http 链接）。

#### 4.6. 线程与进程
1. 一个程序至少有一个进程,一个进程至少有一个线程
2. 线程的划分尺度小于进程，使得多线程程序的并发性高
3. 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率
4. 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制 
5. 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别

#### 4.7. 服务器推送
1. html5 websocket
2. WebSocket 通过 Flash
3. XHR 长轮询
    客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。 
4. XHR Multipart Streaming
5. 不可见的Iframe
    在页面里嵌入一个隐蔵iframe，将这个隐蔵iframe的src属性设为对一个长连接的请求或是采用xhr请求，服务器端就能源源不断地往客户端输入数据。 
6. script 标签的长时间连接(可跨域)

#### 4.8. Gulp、Webpack比较
Gulp
* 为规范前端开发流程，实现前后端分离、模块化开发、版本控制、文件合并与压缩、mock数据等功能的一个前端自动化构建工具。
* 就像是一个产品的流水线，整个产品从无到有，都要受流水线的控制，在流水线上我们可以对产品进行管理。
* 是通过task对整个开发过程进行构建。

Webpack
* 当下最热门的前端资源模块化管理和打包工具
* 可以很好的管理模块以及各个模块之间的依赖
* 对js、css、图片等资源文件都支持打包
* 有独立的配置文件webpack.config.js
* 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间
* 可以生成优化且合并后的静态资源

两大特色：
* 代码可以自动完成编译。
* loader 可以处理各种类型的静态文件，并且支持串联操作

#### 4.9. 三次握手
> TCP在传输之前会进行三次沟通，一般称为“三次握手”，传完数据断开的时候要进行四次沟通，一般称为“四次挥手”。

两个序号和六个标志位：
两个序号位：
* 序号：seq序号，占32位，用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。
* 确认序号：ack序号，占32位，只有ACK标志位为1时，确认序号字段才有效，ack=seq+1。

标志位
* URG：紧急指针（urgent pointer）有效。
* ACK：确认序号有效。
* PSH：接收方应该尽快将这个报文交给应用层。
* RST：重置连接。
* SYN：发起一个新连接。
* FIN：释放一个连接。

![tcp](/img/in-post/post-web-nowcoder/tcp.png)
1. 客户端给服务器发送数据包（带SYN标志的数据包）。此时服务器确认自己可以接收客户端的包，而客户端不确认服务器是否接收到了自己发的数据包。

2. 服务器端回复（回传一个带有SYN/ACK标志的数据包以示传达确认信息）客户端。此时客户端确认自己发的包被服务器收到，也确认自己可以正常接收服务器包，客户端对此次通信没有疑问了。服务器也可以确认自己能接收到客户端的包，但不能确认客户端能否接收自己发的包。

3. 客户端回复（发送端再回传一个带ACK标志的数据包，代表“握手”结束）服务器。客户端已经没有疑问了，服务器也确认刚刚客户端收到了自己的数据包。两边都没有问题，开始通信。

为什么要三次握手：
* 为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。也防止了服务器端的一直等待而浪费资源
* TCP作为一种可靠传输控制协议，其核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！

四次挥手
1. 主机向服务器发送一个断开连接的请求（不早了，我该走了）,发送一个FIN报文段；
2. 服务器接到请求后发送确认收到请求的信号（知道了）回一个ACK报文段；
3. 服务器向主机发送断开通知（我也该走了）发送FIN报文段，请求关闭连接；
4. 主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后也断开连接；

#### 4.10. TCP和UDP的区别
* TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来

* UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！
UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。

#### 4.11. HTTP HTTPS HTTP2.0
![tcp](/img/in-post/post-web-nowcoder/http.png)

**HTTP HTTPS**
![http](/img/in-post/post-web-nowcoder/http-https.png)

* HTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS
* 默认HTTP的端口号为80，HTTPS的端口号为443
* HTTPS 相对于HTTP 性能上差点，因为多了SSL/TLS 的几次握手和加密解密的运算处理，但是加密解密的运算处理已经可以通过特有的硬件来加速处理。

**HTTP2.0的新特性**
* 新的二进制格式（Binary Format）
    - HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多
    - 二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
* 多路复用（MultiPlexing）
    即连接共享，即每一个request都是是用作连接共享机制的。
    一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。多路复用原理图：
![multiplexing](/img/in-post/post-web-nowcoder/multiplexing.png)
* header压缩
    HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
* 服务端推送（server push）

更多了解：
* [学习前端前必知的——HTTP协议详解](http://www.cnblogs.com/chaoran/p/4783633.html)
* [HTTP,HTTP2.0,SPDY,HTTPS你应该知道的一些事](http://web.jobbole.com/87695/)

## 5. 代码
#### 5.1. 通用的事件监听器
```js
// event(事件)工具集，来源：github.com/markyun
markyun.Event = {
    // 页面加载完成后
    readyEvent: function (fn) {
        if (fn == null) {
            fn = document;
        }
        var oldonload = window.onload;
        if (typeof window.onload != 'function') {
            window.onload = fn;
        } else {
            window.onload = function () {
                oldonload();
                fn();
            };
        }
    },
    // 视能力分别使用dom0||dom2||IE方式 来绑定事件
    // 参数： 操作的元素,事件名称 ,事件处理程序
    addEvent: function (element, type, handler) {
        if (element.addEventListener) {
            //事件类型、需要执行的函数、是否捕捉
            element.addEventListener(type, handler, false);
        } else if (element.attachEvent) {
            element.attachEvent('on' + type, function () {
                handler.call(element);
            });
        } else {
            element['on' + type] = handler;
        }
    },
    // 移除事件
    removeEvent: function (element, type, handler) {
        if (element.removeEnentListener) {
            element.removeEnentListener(type, handler, false);
        } else if (element.detachEvent) {
            element.detachEvent('on' + type, handler);
        } else {
            element['on' + type] = null;
        }
    },
    // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获)
    stopPropagation: function (ev) {
        if (ev.stopPropagation) {
            ev.stopPropagation();
        } else {
            ev.cancelBubble = true;
        }
    },
    // 取消事件的默认行为
    preventDefault: function (event) {
        if (event.preventDefault) {
            event.preventDefault();
        } else {
            event.returnValue = false;
        }
    },
    // 获取事件目标
    getTarget: function (event) {
        return event.target || event.srcElement;
    },
    // 获取event对象的引用，取到事件的所有信息，确保随时能使用event；
    getEvent: function (e) {
        var ev = e || window.event;
        if (!ev) {
            var c = this.getEvent.caller;
            while (c) {
                ev = c.arguments[0];
                if (ev && Event == ev.constructor) {
                    break;
                }
                c = c.caller;
            }
        }
        return ev;
    }
};
```

#### 5.2. 数组去重
建一个空对象和空数组，循环遍历需要去重的数组，判断对象有没有此属性，没有的话就给对象添加此属性，并向空数组中push这个值。
```js
//es5
functionunique(arr){
      var obj = {}
    var result = []
 for(var i in arr){
             if(!obj[arr[i]]){
                       obj[arr[i]] = true;
                     result.push(arr[i]);
           }
       }
       return result;
}
//es6
[...new Set(arr)]
```

#### 5.3. 冒泡排序
相邻两个对比，最后把最大的排到了最后，重复此过程。
```js
functionbubbleSort(arr) {
      var len = arr.length;
   for (var i = 0; i < len; i++) {
        for (var j = 0; j < len - 1 - i; j++) {
                 if (arr[j] > arr[j+1]) {        //相邻元素两两对比
                              var temp = arr[j+1];        //元素交换
                              arr[j+1] = arr[j];
                             arr[j] = temp;
                  }
              }
       }
       return arr;
}
```

#### 5.4. 选择排序
寻找最小的数，保存索引，然后与第一层循环其下标对于的值进行交换
```js
functionselectionSort(arr) {
   var len = arr.length;
   var minIndex, temp;
     for (var i = 0; i < len - 1; i++) {
            minIndex = i;
          for (var j = i + 1; j <len; j++) {
                     if (arr[j] < arr[minIndex]) {     //寻找最小的数
                              minIndex = j;                 //将最小数的索引保存
                       }
              }
              temp = arr[i];
         arr[i] =arr[minIndex];
        arr[minIndex] =temp;
   }
       return arr;
}
```

#### 5.5. 快速排序
选取一个记录作为中间轴，然后将比‘这个记录值’小的移到‘记录值’之前，大的移到之后，然后递归
```js
functionquickSort(arr) {
    if (arr.length == 0) {
        return []; // 返回空数组
    }
    var cIndex = Math.floor(arr.length / 2);
    var c = arr.splice(cIndex, 1);
    var l = [];
    var r = [];
    for (var i = 0; i < arr.length; i++) {
        if (arr[i] < c) {
            l.push(arr[i]);
        } else {
            r.push(arr[i]);
        }
    }
    return quickSort(l).concat(c, quickSort(r));
}
```