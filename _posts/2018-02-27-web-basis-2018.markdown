---
layout:     post
title:      "Web basis summary"
subtitle:   "basic of front-end development"
date:       2018-02-27 19:55:00
author:     "Chaoran"
header-img: "img/post-bg-web-basic.jpg"
noToc:      true
tags:
    - 前端开发
---

> “To be is to be perceived. ”

* 目录
{:toc #toc}

## 1. JavaScript
#### 1.1. 基础语法
> 包括：变量声明、数据类型、函数、控制语句、内置对象等
##### 1.1.1. 变量声明
ES5：
```js
var         //普通变量 
function    //函数
```
ES6新增:
```js
let         //普通变量
const       //静态变量
import      //模块
class       //类
```
##### 1.1.2. 数据类型
###### -- 类型介绍
ES5:
`String、Number、Boolean、Null、Undefined、Object`
ES6增:
`Symbol`
**其中，object为引用，其他为基本类型**
* 基本类型
    占据空间固定，是简单的数据段，将其存储在**栈**(stack)中(按值访问)   *便于提升变量查询速度*
    为了便于操作这类数据，ECMAScript提供了 3 个 基本包装类型 ：Boolean、Number 和 String
    - 基本包装类型
        一种特殊的引用类型，每当读取一个基本类型值的时候，JS内部就会创建一个对应的包装对象，从而可以调用一些方法来操作这些数据
* 引用类型
    - 由于其值的大小会改变，所以不能将其存放在栈中，否则会降低变量查询速度
    - 将其存储在**堆**(heap)中，存储在变量处的值是一个指针，指向存储对象的内存处(按址访问)
    - 可以为其添加、改变和删除属性和方法；但基本类型不可以添加属性和方法

###### -- 类型判断
* 原始类型
    - typeof
* 引用类型
    - isinstanceof -- 判断已知对象
    - constructor -- 根据对象的constructor判断
    *constructor本来是原型对象上的属性，指向构造函数。但是根据实例对象寻找属性的顺序，若实例对象上没有实例属性或方法时，就去原型链上寻找，因此，实例对象也是能使用constructor属性的*
    - Object.prototype.toString.call 
    - $.type() -- 万能判断
    
    ```js
    var a = new Array();
    console.log(a instanceof Array) // a是否Array的实例  true
    console.log(a.constructor == Array)  //  a实例所对应的构造函数是否为Array  true

    // constructor属性是可以被修改的，会导致检测出的结果不正确
    function Dog(){
    
    }
    function Cat(){
    
    }
    Cat.prototype = new Dog();
    var m= new Cat();
    console.log(m.constructor==Cat); // false
    console.log(John.constructor==Person); // true
    // instanceof 对于直接或间接引用都是true
    console.log(m instanceof Cat); // true
    console.log(John instanceof Person); // true

    //Object.prototype.toString.call 
    function a() { };
 
    var toString = Object.prototype.toString;
    console.log(toString.call(new Date) === '[object Date]');   //true
    console.log(toString.call(new String) ==='[object String]');//true
    console.log(toString.call(a) ==='[object Function]');       //true

    //$.type
    jQuery.type( undefined ) === "undefined"          // true
    jQuery.type() === "undefined"                     // true
    jQuery.type( null ) === "null"                    // true
    jQuery.type( true ) === "boolean"                 // true
    ```
#### 1.1.3. 函数
* 普通函数 -- 直接调用
* 构造函数 -- new 创建对象
* 对象方法 -- 对象调用

#### 1.1.4. 内置对象
* window
    - 全局对象，主要描述浏览器窗口相关的属性和状态
* Date
* Array
* JSON
    - 主要用于对象的序列化和反序列化
    - 实现对象的深拷贝
* RegExp

##### -- 浅复制与深拷贝
1. 浅复制
    对对象地址的复制，并没有开辟新的栈，复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变
2. 深拷贝
    开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

**方法**
1. 递归
    ```js
    var china = {
        nation : '中国',
        birthplaces:['北京','上海','广州'],
        skincolr :'yellow',
        friends:['sk','ls']
    }
    //深复制，要想达到深复制就需要用递归
    function deepCopy(o,c){
        var c = c || {}
        for(var i in o){
            if(typeof o[i] === 'object'){
                //要考虑深复制问题了
                if(o[i].constructor === Array){
                    //这是数组
                    c[i] =[]
                }else{
                    //这是对象
                    c[i] = {}
                }
                deepCopy(o[i],c[i])
            }else{
                c[i] = o[i]
            }
        }
        return c
    }
    var result = {name:'result'}
    result = deepCopy(china,result)
    console.dir(result)
    ```
    ![递归](/img/in-post/post-web-basic/digui.png)

2. JSON
```js
var test ={
    name:{
        xing:{ 
            first:'张',
            second:'李'
        },
        ming:'老头'
    },
    age :40,
    friend :['隔壁老王','宋经纪','同事']
}
var result = JSON.parse(JSON.stringify(test))
result.age = 30
result.name.xing.first = '往'
result.friend.push('fdagldf;ghad')
console.dir(test)
console.dir(result)
```
![json](/img/in-post/post-web-basic/json.png)

#### 1.2. 函数原型链
> JS是一种基于对象的语言，但在ES6 之前是不支持继承的，为了具备继承的能力，Javascript 在 函数对象上建立了原型对象prototype，并以函数对象为主线，从上至
下，在JS内部构建了一条 原型链

Object 是所有对象的祖宗， 任何对象所建立的原型链最终都指向了Object

简单来说:
建立了变量查找机制，当访问一个对象的属性时，先查找对象本身是否存在，如果不存在就去该对象所在的原型连上去找，直到Object对象为止，如果都没有找到该属性才会返回undefined。因此，我们可以通过原型链来实现JS继承

#### 1.3. 函数作用域
> 变量在声明它们的函数体以及这个函数体嵌套的任意函数体

**JS中没有块级作用域，只有函数作用域**
导致JS中出现了**变量提升**的问题
    —— 将变量声明提升到它所在作用域的最开始的部分
为了解决变量提升带来的副作用，ES6新增了let 命令来声明变量，let 所声明的变量只在 let 命令所在的代码块内有效，所以不存在变量提升问题

#### 1.4. this 指针
> this 指针存在于函数中，用以标识函数运行时所处的上下文

* 普通函数
    始终指向全局对象window
* 构造函数
    指向新创建的对象
* 方法
    指向调用该方法的对象
* call、apply 和 bind 
    方法来改变函数的 this 指向，其中，call 和 apply 主动执行函数，bind一般在事件回调中使用， call 和 apply的区别只是参数的传递方式不同

#### 1.5. new 操作符
> 函数的创建有三种方式，即 显式声明、匿名定义 和 new Function()

JS将新对象的原型链指向了构造函数的原型对象，于是就在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型prototype中的方法和属性

#### 1.6. 闭包
> 具有独立作用域的静态执行环境

和函数作用域不同的是:
* 闭包的作用域
    静态的，可以永久保存局部资源
* 函数作用域
    只存在于运行时，函数执行结束后立即销毁
    
因此，闭包可以形成一个独立的执行过程

#### 1.7. 单线程和异步
JavaScript
* 单线程语言，在浏览器中，当JS代码被加载时，浏览器会为其分配一个主线程来执行任务(函数)
    主线程会形成一个全局执行环境，执行环境在栈中采用后进先出(LIFO)的顺序来执行代码块，以保证所有的函数能按照正确的顺序被执行
* 执行环境中维护了一个异步队列(也叫工作线程)，并将这些耗时任务放入队列中进行等待
    - 如ajax请求、定时器、事件等
    - 这些任务的执行时机并不确定，只有当主线程的任务执行完成以后，主线程才会去检查异步队列中的任务是否需要开始执行。
    - JS中的 setTimeout 和 setInterval 就是典型的异步操作，它们会被放入异步队列中等待，即使 setTimeout(0)也不会被立即执行，需要等到当前同步任务结束后才会被执行。

#### 1.8. 异步通信
> 浏览器专门用来和服务器进行交互的异步通讯技术

##### 1.8.1. Ajax
* Ajax是浏览器专门用来和服务器进行交互的异步通讯技术
* 其核心对象是XMLHttpRequest，通过该对象可以创建一个Ajax请求
* Ajax请求是一个耗时的异步操作，当请求发出以后，Ajax提供了两个状态位来描述请求在不同阶段的状态，这两个状态位分别是
    - readyState 
    - status 
    readyState 通过5个状态码来描述一个请求的5个阶段：
    0 - 请求未发送，初始化阶段
    1 - 请求发送中，服务器还未收到请求
    2 - 请求发送成功，服务器已收到请求
    3 - 服务器处理完成，开始响应请求，传输数据
    4 - 客户端收到请求，并完成了数据下载，生成了响应对象
    status
    1XX  提示信息 - 表示请求已被成功接收，继续处理
2XX  成功 - 表示请求已被成功接收，理解，接受
3XX  重定向 - 要完成请求必须进行更进一步的处理
4XX  客户端错误 -  请求有语法错误或请求无法实现
5XX  服务器端错误 -   服务器未能实现合法的请求

常见问题：
* timeout 只会影响readyState，而不会影响status，因为超时只会中断数据传输，但不会影响服务器的处理结果。 如果 timeout 设置的不合理，就会导致响应码status 是200，但 response里却没有数据，这种情况就是服务器正确响应了请求，但数据的下载被超时中断了。

HTTP 相关请见：<http://www.cnblogs.com/chaoran/p/4783633.html>
##### 1.8.2. JSONP && XSS
浏览器设置了安全限制——JavaScript或Cookie只能访问同域下的内容——同源策略

只允许请求和当前地址同域的服务器资源。但不限制脚本和标签发送跨域请求，比如script 和 img 标签，因此可以利用脚本跨域能力来实现跨域请求，即JSONP 的原理。

JSONP虽然可以解决跨域问题，但只能是get请求，并且没有有效的错误捕获机制
为了解决这个问题，XMLHttpRequest Level2 提出了CORS 模型，即 跨域资源共享， 它不是一个新的API，而是一个标准规范，当浏览器发现该请求需要跨域时，就会自动在头信息中添加一个 Origin字段，用以说明本次请求来自哪个源。服务器根据这个值，决定是否同意这次请求。 

随着移动端的快速发展，Web技术的应用场景正在变得越来越复杂， 关注点分离 原则在系统设计层面就显得越来越重要，而XMLHttpRequest 是 Ajax 最古老的一个接口，因而不太符合现代化的系统设计理念。因此，浏览器提供了一个新的 Ajax 接口，即 Fetch API ，Fetch API 是基于Promise 思想设计的，更符合关注点分离原则。

JSONP && CORS 详解：<http://www.cnblogs.com/chaoran/p/6579588.html>
fetch 进阶指南： <http://web.jobbole.com/91161/>
JavaScript 异步编程的4种方式：<http://www.ruanyifeng.com/blog/2012/12/asynchronous%EF%BC%BFjavascript.html>

#### 1.9. 模块化
模块加载方案，最主要有 CMD 和 AMD 两种，分别以commonjs 和 requirejs为代表

ES6 在语言标准的层面上，实现了模块化编程，其设计思想是，**尽量静态化**，使得编译时就能确定模块的依赖关系，即**编译时加载**

CMD和AMD是在运行时确定依赖关系，即**运行时加载**。

AMD && CMD: <http://www.cnblogs.com/chaoran/p/6696690.html>

##### ES6 模块化
每一个ES6模块都是一个包含JS代码的文件，模块本质上就是一段脚本，而不是用module关键字定义一个模块，但是模块与脚本还是有两点区别：
* 在ES6模块中，无论你是否加入“use strict;”语句，默认情况下模块都是在严格模式下运行。
* 在模块中你可以使用import和export关键字。

默认情况下，你在模块中的所有声明相对于模块而言都是寄存在本地的。如果你希望公开在模块中声明的内容，并让其它模块加以使用，你一定要导出这些功能。想要导出模块的功能有很多方法，其中最简单的方式是添加export关键字，可以导出所有的最外层函数、类以及var、let或const声明的变量。

es6中 代码就是模块，不是一段脚本，所以所有的声明都被限定在模块的作用域中，对所有脚本和模块全局不可见。你需要做的是将组成模块公共API的声明全部导出。

**webpack**
在编译时计算所有依赖并将所有模块打包成一个文件，通过网络一次传输所有模块
*减少加载模块时的网络往返时间*


深入浅出ES6（模块）：<http://www.infoq.com/cn/articles/es6-in-depth-modules>
#### 1.10. Node.js
> 一个基于 Chrome V8 引擎的 JavaScript运行环境

Node.js在服务端的优势是，它采用单线程和异步I/O模型，实现了一个高并发、高性能的运行时环境。相比传统的多线程模型，Node.js实现简单，并且可以减少资源开销。

参考：
<https://www.zhihu.com/question/23031215/answer/124017500>
<https://mp.weixin.qq.com/s?__biz=MzUzOTM0MTE4OQ==&mid=100000096&idx=1&sn=4d9f2f43a8e29a1e9484bcad1e114c15&chksm=7ac8b98a4dbf309c495a4a4568757e2d21ae5265d365330a9d23e96f0457957539d43e9522a0&mpshare=1&scene=1&srcid=0226TkvgVT54Lk6u5XuL256h#rd>
